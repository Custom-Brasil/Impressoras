// File Revision
// Rev 1.00
//
// - rel 1.00: first release

// NOTE: Please DO NOT EDIT THIS FILE

///
/// \file ccw_Status.h
/// \brief Data and parameters definition.
///


#ifndef _CCW_STATUS_H__
#define _CCW_STATUS_H__


#pragma pack(1)


/**
* Printer Status Struct
*/
typedef struct {

	//**************************************
	//Status Vars: BYTE 1
	//**************************************

	/**
	* Indicates that the printer is in NO PAPER Status.
	* Refer to Printer manual to know if this status is supported by the device
	*/
	BOOL stsNOPAPER;
	/**
	* Indicates that the printer is in NEAR PAPER END Status.
	* Refer to Printer manual to know if this status is supported by the device
	*/
	BOOL stsNEARENDPAP;
	/**
	* Indicates that the printer is in TICKET OUT Status.
	* Refer to Printer manual to know if this status is supported by the device
	*/
	BOOL stsTICKETOUT;

	//**************************************
	//Status Vars: BYTE 2
	//**************************************

	/**
	* Indicates that the printer is in HEAD UP Status.
	* Refer to Printer manual to know if this status is supported by the device
	*/
	BOOL stsNOHEAD;
	/**
	* Indicates that the printer is in COVER OPEN Status.
	* Refer to Printer manual to know if this status is supported by the device
	*/
	BOOL stsNOCOVER;
	/**
	* Indicates that the printer is in SPOOLING Status.
	* Refer to Printer manual to know if this status is supported by the device
	*/
	BOOL stsSPOOLING;
	/**
	* Indicates that the printer is in PAPER ROLLING Status.
	* Refer to Printer manual to know if this status is supported by the device
	*/
	BOOL stsPAPERROLLING;
	/**
	* Indicates that the printer is in LFPRESSED Status.
	* Refer to Printer manual to know if this status is supported by the device
	*/
	BOOL stsLFPRESSED;
	/**
	* Indicates that the printer is in FFPRESSED Status.
	* Refer to Printer manual to know if this status is supported by the device
	*/
	BOOL stsFFPRESSED;

	//**************************************
	//Status Vars: BYTE 3
	//**************************************

	/**
	* Indicates that the printer is in OVERTEMPERATURE Status.
	* Refer to Printer manual to know if this status is supported by the device
	*/
	BOOL stsOVERTEMP;
	/**
	* Indicates that the printer is in OVERVOLTAGE Status.
	* Refer to Printer manual to know if this status is supported by the device
	*/
	BOOL stsHLVOLT;
	/**
	* Indicates that the printer is in PAPER JAM Status.
	* Refer to Printer manual to know if this status is supported by the device
	*/
	BOOL stsPAPERJAM;

	//**************************************
	//Status Vars: BYTE 4
	//**************************************

	/**
	* Indicates that the printer is in CUTTER ERROR Status.
	* Refer to Printer manual to know if this status is supported by the device
	*/
	BOOL stsCUTERROR;
	/**
	* Indicates that the printer is in RAM ERROR Status.
	* Refer to Printer manual to know if this status is supported by the device
	*/
	BOOL stsRAMERROR;
	/**
	* Indicates that the printer is in EEPROM ERROR Status.
	* Refer to Printer manual to know if this status is supported by the device
	*/
	BOOL stsEEPROMERROR;

	/// Reserved fot future development. Do not use
	BYTE reserved[1024];
} PrinterStatusStruct;


/**
* Convert status indicated by *pStatus to an wchar_t string.
*
* @param[in] pStatus		Pointer to \ref PrinterStatusStruct which contains the current status
*
* @param[out] szBufferOut	Pointer to a null-terminated char buffer containing a text description for the status.
*							The buffer must be allocated by the calling process
*
* @param[in] dwBuffCharSize	size of the text buffer
*/
static void PrinterStatusStructToText(PrinterStatusStruct* pStatus, wchar_t* szBufferOut, DWORD dwBuffCharSize)
{		
	if (pStatus == NULL || szBufferOut == NULL)
	{
		return;
	}

	wchar_t* szApp = new wchar_t[MAXCHARBUFFER];
	ZeroMemory(szApp, MAXCHARBUFFER * sizeof(wchar_t));

	// Create string
	wcscpy_s(szBufferOut, dwBuffCharSize, L"Scanner status: ");

	// Add all status	
	//

	//**************************************
	//Status Vars: BYTE 1
	//**************************************
	if (pStatus->stsNOPAPER)
	{	
		swprintf_s(szApp, MAXCHARBUFFER, L"NO PAPER; ");
		wcsncat_s(szBufferOut, dwBuffCharSize, szApp, (dwBuffCharSize - wcsnlen(szBufferOut, dwBuffCharSize) + 1));
	}
	if (pStatus->stsNEARENDPAP)
	{
		swprintf_s(szApp, MAXCHARBUFFER, L"NEAR PAPER END; ");
		wcsncat_s(szBufferOut, dwBuffCharSize, szApp, (dwBuffCharSize - wcsnlen(szBufferOut, dwBuffCharSize) + 1));
	}
	if (pStatus->stsTICKETOUT)
	{
		swprintf_s(szApp, MAXCHARBUFFER, L"TICKET OUT; ");
		wcsncat_s(szBufferOut, dwBuffCharSize, szApp, (dwBuffCharSize - wcsnlen(szBufferOut, dwBuffCharSize) + 1));
	}
	
	//**************************************
	//Status Vars: BYTE 2
	//**************************************
	if (pStatus->stsNOHEAD)
	{
		swprintf_s(szApp, MAXCHARBUFFER, L"HEAD UP; ");
		wcsncat_s(szBufferOut, dwBuffCharSize, szApp, (dwBuffCharSize - wcsnlen(szBufferOut, dwBuffCharSize) + 1));
	}
	if (pStatus->stsNOCOVER)
	{
		swprintf_s(szApp, MAXCHARBUFFER, L"COVER OPEN; ");
		wcsncat_s(szBufferOut, dwBuffCharSize, szApp, (dwBuffCharSize - wcsnlen(szBufferOut, dwBuffCharSize) + 1));
	}
	if (pStatus->stsSPOOLING)
	{
		swprintf_s(szApp, MAXCHARBUFFER, L"SPOOLING; ");
		wcsncat_s(szBufferOut, dwBuffCharSize, szApp, (dwBuffCharSize - wcsnlen(szBufferOut, dwBuffCharSize) + 1));
	}
	if (pStatus->stsPAPERROLLING)
	{
		swprintf_s(szApp, MAXCHARBUFFER, L"PAPER ROLLING; ");
		wcsncat_s(szBufferOut, dwBuffCharSize, szApp, (dwBuffCharSize - wcsnlen(szBufferOut, dwBuffCharSize) + 1));
	}
	if (pStatus->stsLFPRESSED)
	{
		swprintf_s(szApp, MAXCHARBUFFER, L"LF PRESSED; ");
		wcsncat_s(szBufferOut, dwBuffCharSize, szApp, (dwBuffCharSize - wcsnlen(szBufferOut, dwBuffCharSize) + 1));
	}
	if (pStatus->stsFFPRESSED)
	{
		swprintf_s(szApp, MAXCHARBUFFER, L"FF PRESSED; ");
		wcsncat_s(szBufferOut, dwBuffCharSize, szApp, (dwBuffCharSize - wcsnlen(szBufferOut, dwBuffCharSize) + 1));
	}

	//**************************************
	//Status Vars: BYTE 3
	//**************************************
	if (pStatus->stsOVERTEMP)
	{
		swprintf_s(szApp, MAXCHARBUFFER, L"OVER TEMPERATURE; ");
		wcsncat_s(szBufferOut, dwBuffCharSize, szApp, (dwBuffCharSize - wcsnlen(szBufferOut, dwBuffCharSize) + 1));
	}
	if (pStatus->stsHLVOLT)
	{
		swprintf_s(szApp, MAXCHARBUFFER, L"OVER VOLTAGE; ");
		wcsncat_s(szBufferOut, dwBuffCharSize, szApp, (dwBuffCharSize - wcsnlen(szBufferOut, dwBuffCharSize) + 1));
	}
	if (pStatus->stsPAPERJAM)
	{
		swprintf_s(szApp, MAXCHARBUFFER, L"PAPER JAM; ");
		wcsncat_s(szBufferOut, dwBuffCharSize, szApp, (dwBuffCharSize - wcsnlen(szBufferOut, dwBuffCharSize) + 1));
	}

	//**************************************
	//Status Vars: BYTE 4
	//**************************************
	if (pStatus->stsCUTERROR)
	{
		swprintf_s(szApp, MAXCHARBUFFER, L"CUTTER ERROR; ");
		wcsncat_s(szBufferOut, dwBuffCharSize, szApp, (dwBuffCharSize - wcsnlen(szBufferOut, dwBuffCharSize) + 1));
	}
	if (pStatus->stsRAMERROR)
	{
		swprintf_s(szApp, MAXCHARBUFFER, L"RAM ERROR; ");
		wcsncat_s(szBufferOut, dwBuffCharSize, szApp, (dwBuffCharSize - wcsnlen(szBufferOut, dwBuffCharSize) + 1));
	}
	if (pStatus->stsEEPROMERROR)
	{
		swprintf_s(szApp, MAXCHARBUFFER, L"EEPROM ERROR; ");
		wcsncat_s(szBufferOut, dwBuffCharSize, szApp, (dwBuffCharSize - wcsnlen(szBufferOut, dwBuffCharSize) + 1));
	}


	// If not status is segnaled
	if (szApp[0] == '\0')
	{// Nothing segnaled
		swprintf_s(szApp, MAXCHARBUFFER, L"Nothing to report.");
		wcsncat_s(szBufferOut, dwBuffCharSize, szApp, (dwBuffCharSize - wcsnlen(szBufferOut, dwBuffCharSize) + 1));
	}

	delete[] szApp;
}

#pragma pack()

#endif



